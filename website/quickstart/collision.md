## 示例插件的命令表

### 赌石

| 命令       | 状态     | 方法   |
| ---------- | -------- | ------ |
| 赌石/stone | 空状态   | wakeup |
| 退出/exit  | 任意状态 | rest   |
| 敲/hit     | idle     | hit    |

### 木鱼

| 命令              | 状态     | 方法     |
| ----------------- | -------- | -------- |
| 木鱼/muyu         | 空状态   | wakeup   |
| 退出/exit         | 任意状态 | rest     |
| 敲/hit            | idle     | hit      |
| 查询功德/query    | idle     | query    |
| 调整步进/set step | idle     | set_step |

### 人员登记

| 命令         | 状态   | 子状态 | 方法       |
| ------------ | ------ | ------ | ---------- |
| 查看登记情况 | 空状态 | 空状态 | show       |
| 我要登记     | 空状态 | 空状态 | start      |
| *任意文字*   | 空状态 | name   | input_name |
| *任意文字*   | 空状态 | age    | input_age  |

## 避免命令碰撞

示例中的三个插件，通过ayaka可以一定程度上解决命令碰撞的问题

假设机器人收到了一条消息`敲`，但`赌石`、`木鱼`、`人员登记`都有相应的命令规则符合，显然你并不希望他们三个全都对该消息做出响应

借助ayaka，这种情况并不会发生

## 碰撞域

![图片](./1.png)

当机器人收到`赌石`命令后，碰撞域发生变化，这是因为在`wakeup`函数中，赌石的状态从`空状态`变更为了`idle`

![图片](./2.png)

碰撞域之外的回调不会参与竞争消息响应，因此只要红色的回调没有同时处于碰撞域之中，就不会出现命令碰撞

## 状态

所有的命令回调、文字回调都会要求注册在某个猫猫的某个状态下，之后，仅当该猫猫处于该状态时，这些回调才能进入碰撞域，从而有资格处理消息

## 通用状态

为方便起见，设计了`*`状态作为通用状态，它匹配一切非空状态

此时ayaka将拒绝所有其他状态下的命令

但是有一种特殊状态除外，那就是`*`（通用状态），它匹配所有状态，在任意状态下均被ayaka接受

## 便利的数据缓存

ayaka为每个群聊均设置了一份字典

各个插件中的猫猫均可以通过`cat.cache`访问到该字典中的一部分空间：

```
cat.cache <-> total_dict[group_id][cat.name]
```

各个猫猫获取到的空间是相互独立的，不会发生冲突

同时，ayaka还设计了`cat.get_data`、`cat.pop_data`方法读写`cat.cache`

可以将`BaseModel`放入其中使用，解决了直接读写字典时缺乏类型提示的问题

注意：缓存数据会在bot重启后丢失

## 下一步

<div align="right">
    在这里~ ↘
</div>
